










'use strict';var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};

var ReactUpdates=require('ReactUpdates');
var Transaction=require('Transaction');

var emptyFunction=require('fbjs/lib/emptyFunction');

var RESET_BATCHED_UPDATES={
initialize:emptyFunction,
close:function close(){
ReactDefaultBatchingStrategy.isBatchingUpdates=false;
}};


var FLUSH_BATCHED_UPDATES={
initialize:emptyFunction,
close:ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)};


var TRANSACTION_WRAPPERS=[FLUSH_BATCHED_UPDATES,RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction(){
this.reinitializeTransaction();
}

_extends(ReactDefaultBatchingStrategyTransaction.prototype,Transaction,{
getTransactionWrappers:function getTransactionWrappers(){
return TRANSACTION_WRAPPERS;
}});


var transaction=new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy={
isBatchingUpdates:false,





batchedUpdates:function batchedUpdates(callback,a,b,c,d,e){
var alreadyBatchingUpdates=ReactDefaultBatchingStrategy.isBatchingUpdates;

ReactDefaultBatchingStrategy.isBatchingUpdates=true;


if(alreadyBatchingUpdates){
return callback(a,b,c,d,e);
}else{
return transaction.perform(callback,null,a,b,c,d,e);
}
}};


module.exports=ReactDefaultBatchingStrategy;